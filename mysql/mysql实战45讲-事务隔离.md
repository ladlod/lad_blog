# mysql实战45讲-事务隔离
> 大家日常工作中一定对事务不陌生，无论是和数据库打交道，还是我们的分布式系统中，都经常需要用到事务，那么mysql事务之间的隔离是怎么实现的呢？
## 基础概念
### 什么是事务
**事务**是计算机常用的一种机制，包含了一组计算机操作指令，事务把所有指令作为一个整体一起向系统提交或撤销。即事务中的所有指令，要么都执行，要么都不执行，是一个不可分割的工作逻辑单元。
### 事务的特性
事务具有四个特性，**原子性(Atomicity)**，**一致性(Consistency)**，**隔离性(Isolation)**，**持久性(Durability)**
- **原子性**指事务是一个完整的操作，必须作为一个整体提交或回滚。
- **一致性**指事务执行前后，数据的完整性必须保持一致。
- **隔离性**指所有事务对数据的操作彼此之间是隔离的，事务之间是独立的，不应以任何方式依赖或影响其它事务。
- **持久性**指一个事务一旦被提交，它对数据的改变就是永久性的。
### 隔离性与隔离级别
当有多个事务并发操作同一数据时，如果隔离性没有保障，就可能出现**脏读(dirty read)**，**不可重复读(non-repeatable read)**，**幻读(phantom read)** 的问题。为了解决上述问题，就有了隔离级别的概念。

在谈隔离级别之前，我们应该可以想到，隔离的越严，效率就会越低，因此我们需要在二者之间找到一个平衡点。mysql将事务的隔离划分为四个级别，**读未提交(read uncommitted)**，**读提交(read committed)**，**可重复读(repeatable read)**，**串行化(serializable)**。
![隔离级别](assets/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png)
#### 读未提交(read uncommitted)
不做任何隔离，一个事务还没commit时，它做的变更就可以被其它事务看到；在**读未提交**的隔离级别下，假设事务A修改某一数据后回滚，事务B查询事务A修改的值时，可能出现读到未提交的脏数据的情况，即**脏读**。
#### 读提交(read committed)
仅当一个事务commit之后，它做的变更才可以被其它事务看到；在**读提交**的隔离级别下，假设事务A修改某一数据，事务B在执行过程中两次查询了事务A修改的值时，可能出现两次查询结果不一致的情况，即**不可重复读**。
#### 可重复读(repeatable read)
一个事物执行过程中，总是和事务启动时看到的数据是一致的；在**可重复读**隔离级别下，假设事务A插入一条数据，事务B在执行过程中两次进行范围查询，可能出现两次查询结果不一致的情况，即**幻读**。
#### 串行化(serializable)
所有事务严格按照串行执行。
## InnoDB事务隔离的实现
> 在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。因此，在不同时刻开启的事务都可以根据回滚记录获取到当前的读视图(read-view)。这种视图读的方式，即我们常说的多版本并发控制(Multi-Version Concurrency Control)。
### innodb的mvcc是怎么实现的？
!! 重点
### read committed和repeatable read是怎么实现的？
innodb通过控制不同的视图创建时机，实现不同的隔离级别。在rc级别下，每次sql执行时创建read-view，在rr级别下，每个事务提交时创建read-view。
### mvcc是否可以彻底解决重复读和幻读的问题？
在前面我们了解到，mvcc使得我们的读操作最终执行为读取read-view，在rr隔离级别下，其它事务无法修改当前事务使用的read-view，所以对**快照读**这一类行为，mvcc可以解决幻读问题。那么是否有查询行为不读取read-view，而是执行**当前读**呢？实际上，在rr隔离级别下，除了普通的select操作，其余操作都是**当前读**。如

``` select ... lock in share mode ```

``` select ... for update ```

``` update ..., delete ..., insert ... ```

我们使用一个case来具体看下，同时开启两个事务，在**快照读**时，事务1在事务2更新前后读取到的数据一致。而如果我们使用**当前读**，可以看到事务1在事务2更新后读取到的数据为最新数据。
![](assets/16667160080110.jpg)
从上述结论可以看出，mvcc也并不能完全解决**重复读**和**幻读**的问题，那么innodb又是怎么解决这两个问题的呢？解决**重复读**并不难，在select语句中如果执行的是当前读，会对当前行上一个S锁，防止有另一个事务并发更新该行数据。但**幻读**是怎么解决的呢？
### 幻读会造成什么影响？
前面我们说到幻读会造成一个事务中前后两次范围查询的结果不同，但这到底会给我们的业务造成什么问题？话不多说直接上例子，还是刚刚的那张表```(a int, b int)```里面有两行数据```(1, 2), (2, 4)```
|time |session1 |session2 |session3|
|-|-|-|-|
|t1 |```select * from t where a = 1 for update```|-|-|
|t2 |-|```update t set a = 1 where b = 2```|-|
|t3 |-|```commit```|-|
|t4 |```select * from t where a = 1 for update```|-|-|
|t5 |-|-|```insert into t values(1, 8)```|
|t6 |-|-|```commit```|
|t7 |```select * from t where a = 1 for update```|-|-|
|t8 |```commit```|-|-|

在t1时刻，我们读到的结果为(1,2)这一行数据；在t4时刻，我们读到的结果为(1,2), (1,4)这两行数据；在t7时刻，我们读到的结果为(1,2), (1,4), (1,8)这三行数据。

由于我们的select语句都加了for update，按照**当前读**的逻辑，以上的三个结果看起来是符合预期的，并且也是合乎逻辑的，那么幻读到底有啥问题呢？

**我们最终要保障的是数据一致性问题**，我们在上述流程中加上一条sql语句
|time |session1 |session2 |session3|
|-|-|-|-|
|t1 |```select * from t where a = 1 for update```|-|-|
|t2 |```update t set b = 0 where a = 1```|-|-|
|t3 |-|```update t set a = 1 where b = 2```|-|
|t4 |-|```commit```|-|
|t5 |```select * from t where a = 1 for update```|-|-|
|t6 |-|-|```insert into t values(1, 8)```|
|t7 |-|-|```commit```|
|t8 |```select * from t where a = 1 for update```|-|-|
|t9 |```commit```|-|-|

在t2时刻，数据库中的数据情况为(1,0),(2,4)；在t4时刻，数据库中的情况变为(1,0),(1,2)；在t7时刻，数据库中的情况变为(1,0),(1,2),(1,8)。

而与此同时，binlog中写入的内容为
```
T4时刻session2提交：update t set a = 1 where b = 2
T7时刻session3提交：insert into t values(1, 8)
T9时刻session1提交：update t set b = 0 where a = 1
```
如果此时我们的数据库按照binlog进行了主从同步，那么从库中的数据将会变为(1,0),(1,0),(1,0)，很显然，这就是幻读造成的问题。
### innodb怎么解决幻读？
产生幻读的主要原因是，在我们进行**当前读**的时候，行锁只能锁住当前行，但插入记录这个动作无法上锁。因此，为了解决这个问题，innodb引入了间隙锁（Gap Lock），在执行**当前读**时，不只会给当前行上锁，还会给可能受到影响的行间隙上锁，这样也就确保了无法插入新的可能产生幻读的记录。mysql锁的种类及实现这里不做展开，后续有专题讲解。
## 事务的启动方式

## 案例case