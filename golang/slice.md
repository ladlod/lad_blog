# leetcode78.子集 slice相关问题排查记录
## 问题
### 题目描述
```
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

示例 1：

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
示例 2：

输入：nums = [0]
输出：[[],[0]]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/subsets
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
### 解题思路
    顺序遍历所有数字，将数字插入所有已有集合
### 代码
```
func subsets(nums []int) [][]int {
	res := make([][]int, 0)
	res = append(res, []int{})

	for _, num := range nums {
		l := len(res)
		for i := 0; i < l; i++ {
			res = append(res, append(res[i], num))
			fmt.Println(res, num)
		}
	}

	return res
}
```
### 问题表现
    在执行测试用例slice长度小于等于4时，解题没有问题，大于4时，出现以下问题
```
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 5] [5] [1 5] [2 5] [1 2 5] [3 5] [1 3 5] [2 3 5] [1 2 3 5] [4 5] [1 4 5] [2 4 5] [1 2 4 5] [3 4 5] [1 3 4 5] [2 3 4 5] [1 2 3 5 5]]
```
    返回结果如上，打印数组生成过程如下
```
[[] [1]] 1
[[] [1] [2]] 2
[[] [1] [2] [1 2]] 2
[[] [1] [2] [1 2] [3]] 3
[[] [1] [2] [1 2] [3] [1 3]] 3
[[] [1] [2] [1 2] [3] [1 3] [2 3]] 3
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3]] 3
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4]] 4
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4]] 4
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4]] 4
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4]] 4
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4]] 4
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4]] 4
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4]] 4
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 4]] 4
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 4] [5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 4] [5] [1 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 4] [5] [1 5] [2 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 4] [5] [1 5] [2 5] [1 2 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 4] [5] [1 5] [2 5] [1 2 5] [3 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 4] [5] [1 5] [2 5] [1 2 5] [3 5] [1 3 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 4] [5] [1 5] [2 5] [1 2 5] [3 5] [1 3 5] [2 3 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 5] [5] [1 5] [2 5] [1 2 5] [3 5] [1 3 5] [2 3 5] [1 2 3 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 5] [5] [1 5] [2 5] [1 2 5] [3 5] [1 3 5] [2 3 5] [1 2 3 5] [4 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 5] [5] [1 5] [2 5] [1 2 5] [3 5] [1 3 5] [2 3 5] [1 2 3 5] [4 5] [1 4 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 5] [5] [1 5] [2 5] [1 2 5] [3 5] [1 3 5] [2 3 5] [1 2 3 5] [4 5] [1 4 5] [2 4 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 5] [5] [1 5] [2 5] [1 2 5] [3 5] [1 3 5] [2 3 5] [1 2 3 5] [4 5] [1 4 5] [2 4 5] [1 2 4 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 5] [5] [1 5] [2 5] [1 2 5] [3 5] [1 3 5] [2 3 5] [1 2 3 5] [4 5] [1 4 5] [2 4 5] [1 2 4 5] [3 4 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 5] [5] [1 5] [2 5] [1 2 5] [3 5] [1 3 5] [2 3 5] [1 2 3 5] [4 5] [1 4 5] [2 4 5] [1 2 4 5] [3 4 5] [1 3 4 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 5] [5] [1 5] [2 5] [1 2 5] [3 5] [1 3 5] [2 3 5] [1 2 3 5] [4 5] [1 4 5] [2 4 5] [1 2 4 5] [3 4 5] [1 3 4 5] [2 3 4 5]] 5
[[] [1] [2] [1 2] [3] [1 3] [2 3] [1 2 3] [4] [1 4] [2 4] [1 2 4] [3 4] [1 3 4] [2 3 4] [1 2 3 5] [5] [1 5] [2 5] [1 2 5] [3 5] [1 3 5] [2 3 5] [1 2 3 5] [4 5] [1 4 5] [2 4 5] [1 2 4 5] [3 4 5] [1 3 4 5] [2 3 4 5] [1 2 3 5 5]] 5
```
    可以看出，在执行数组对[1,2,3]append5的过程中，修改了原数组中[1,2,3,4]的值至[1,2,3,5]
### 猜测
    slice[1,2,3]和[1,2,3,4]底层使用了相同的地址空间，在对[1,2,3]append 5的时候，修改了该地址空间对应的值。
### 疑问
    为什么slice长度小于等于4的时候没有这个问题
## 排查过程
### slice
```
type slice struct {
	ptr unsafe.Pointer // Array pointer
	len int            // slice length
	cap int            // slice capacity
}
```
    其中，ptr指向slice对应的数组地址空间，len表示slice的长度，cap表示slice的容量
### 复现问题
```
package main

import (
	"fmt"
)

func main() {
	a := []int{1, 2, 3}
	b := append(a, 4)
	c := append(a, 5)
	fmt.Printf("a adr:%p v:%v\n", &a[0], a)
	fmt.Printf("b adr:%p v:%v\n", &b[0], b)
	fmt.Printf("c adr:%p v:%v\n", &c[0], c)
}
```
    执行上述代码，结果
```
a adr:0xc000016160 v:[1 2 3]
b adr:0xc00001a180 v:[1 2 3 4]
c adr:0xc00001a1b0 v:[1 2 3 5]
```
    发现并没有复现问题，a，b，c三个slice底层并没有使用同一个地址空间。
```
package main

import (
	"fmt"
)

func main() {
	test := [4]int{1, 2, 3, 4}
	a := test[:3]
	b := append(a, 4)
	c := append(a, 5)
	fmt.Printf("a adr:%p v:%v\n", &a[0], a)
	fmt.Printf("b adr:%p v:%v\n", &b[0], b)
	fmt.Printf("c adr:%p v:%v\n", &c[0], c)
}
```
    执行上述代码，结果
```
a adr:0xc000016160 v:[1 2 3]
b adr:0xc000016160 v:[1 2 3 5]
c adr:0xc000016160 v:[1 2 3 5]
```
    复现问题
### 猜测
    根据slice append的性质，会先判断现有slice的空间是否足够，若不足，则会申请一个新的地址空间，复制原数组结构，若slice空间足够，则在原地址空间后面加上新值。
    可以得出，对测试用例1中，由于slice空间不足，所以b，c均在a之外创建了新的地址空间，修改c时不会对a，b产生影响。而在测试用例2中，由于slice空间有冗余，b，c直接使用了a的地址空间，所以对c进行修改时，会对b的值造成影响，那么slice的容量是怎么分配的呢？
### slice扩容
    对slice进行扩容时，若原地址空间不足，会申请2n大小的新的地址空间，之后对原slice进行拷贝，而在初始化一个slice时，默认申请len大小的地址空间。
```
package main

import (
	"fmt"
)

func main() {
	test := []int{}
	for i := 1; i < 5; i++ {
		test = append(test, i)
		fmt.Println(len(test), cap(test))
	}

	test1 := []int{1}
	test2 := []int{1, 2}
	test3 := []int{1, 2, 3}
	test4 := []int{1, 2, 3, 4}
	fmt.Println(len(test1), cap(test1))
	fmt.Println(len(test2), cap(test2))
	fmt.Println(len(test3), cap(test3))
	fmt.Println(len(test4), cap(test4))
}
```
    执行上述代码，结果
```
1 1
2 2
3 4
4 4
1 1
2 2
3 3
4 4
```
    验证结果正确。
## 总结
### 修改代码
```
func subsets(nums []int) [][]int {
    res := make([][]int, 0)
	res = append(res, []int{})

	for _, num := range nums {
		l := len(res)
		for i := 0; i < l; i++ {
			res = append(res, append([]int{num}, res[i]...))
		}
	}

	return res
}
```
    这样每次都重新声明一个新的长度为1，空间为1的slice，不会造成地址空间重复使用。AC
### 思考
    这种做法对[1,2]的子集[1],[2],[1,2]都会重新申请一个空间，造成内存浪费，是否可以对切片的空间进行重复利用？
